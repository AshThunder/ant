<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ant Kingdom - Rule the Colony</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&family=Creepster&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.development.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.23.6/babel.min.js"></script>
    <script src="https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script src="https://cdn.tailwindcss.com/3.4.1"></script>
    <script src="contracts.js"></script>
</head>
<body>
    <div id="root">
        <div class="loading-screen">
            <h1 class="text-4xl font-bold text-[var(--primary)] mb-6 animate-pulse">Ant Kingdom</h1>
            <div class="progress-container">
                <div id="progress-bar" class="progress-bar" style="width: 100%;"></div>
            </div>
            <p class="mt-4 text-lg">Loading Colony...</p>
        </div>
    </div>
    <script type="text/babel">
        (function () {
            const { useState, useEffect, Component } = React;
            const { ethers } = window;

            class ErrorBoundary extends Component {
                state = { error: null };
                static getDerivedStateFromError(error) {
                    return { error: error.message };
                }
                render() {
                    if (this.state.error) {
                        return (
                            <div className="error Miss p-8 text-center">
                                <h2 className="text-2xl font-bold text-red-300">Colony Error</h2>
                                <p>{this.state.error}</p>
                                <p>Refresh or try again later.</p>
                            </div>
                        );
                    }
                    return this.props.children;
                }
            }

            function ActionModal({ isOpen, onClose, action, throneAmount, isGameActive, onProceed, loading, isCurrentKing, fees }) {
                if (!isOpen) return null;
                const totalFee = fees.withdrawalFee + fees.jackpotFee + (fees.referralFee > 0 ? fees.referralFee : 0);
                const getModalContent = () => {
                    if (isCurrentKing) {
                        return {
                            title: "Royal Mandate",
                            description: "As King, your rule is absolute.",
                            wins: "Earn 100 ANT daily and claim the jackpot after 3 minutes.",
                            losses: "None, your reign is secure.",
                            cost: "None",
                            warning: "Only others may challenge the throne."
                        };
                    }
                    switch (action) {
                        case "becomeKing":
                            const cost = isGameActive ? parseFloat(throneAmount).toFixed(3) : "5.000";
                            const reward = (parseFloat(cost) * 1.4286).toFixed(3);
                            return {
                                title: "Claim the Throne",
                                description: `Pay <span class="text-green-400">${cost} ETH</span> to become King${isGameActive ? " and dethrone the ruler" : " and found the kingdom"}.`,
                                wins: `Rule, set throne to <span class="text-green-400">${reward} ETH</span>, earn 100 ANT daily, claim jackpot after 3 minutes.`,
                                losses: `Lose crown if another claims. ${totalFee}% fee on ETH withdrawals.`,
                                cost: `<span class="text-green-400">${cost} ETH</span> + gas`,
                                warning: "Ensure sufficient ETH."
                            };
                        case "dissolveKingdom":
                            const dissolveCost = parseFloat(throneAmount).toFixed(3);
                            return {
                                title: "Dissolve Kingdom",
                                description: `Pay <span class="text-green-400">${dissolveCost} ETH</span> to dismantle the kingdom.`,
                                wins: `Reset kingdom for a new King.`,
                                losses: `<span class="text-green-400">${dissolveCost} ETH</span> splits 50% to jackpot, 50% to owner.`,
                                cost: `<span class="text-green-400">${dissolveCost} ETH</span> + gas`,
                                warning: "Funds fuel jackpot and owner."
                            };
                        default:
                            return {};
                    }
                };
                const { title, description, wins, losses, cost, warning } = getModalContent();

                return (
                    <div className="ant-modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
                        <div className="ant-modal-content bg-[var(--card-bg)] p-6 rounded-lg max-w-md w-full">
                            <h2 className="text-2xl font-bold text-[var(--primary)] mb-4">{title}</h2>
                            <p className="mb-4" dangerouslySetInnerHTML={{ __html: `<strong>Objective:</strong> ${description}` }}></p>
                            <p className="mb-4" dangerouslySetInnerHTML={{ __html: `<strong>Rewards:</strong> ${wins}` }}></p>
                            <p className="mb-4" dangerouslySetInnerHTML={{ __html: `<strong>Risks:</strong> ${losses}` }}></p>
                            <p className="mb-4" dangerouslySetInnerHTML={{ __html: `<strong>Cost:</strong> ${cost}` }}></p>
                            <p className="text-red-300 mb-6"><strong>Warning:</strong> {warning}</p>
                            <div className="flex justify-end gap-4">
                                <button onClick={onClose} className="ant-button" disabled={loading}>Cancel</button>
                                {!isCurrentKing && (
                                    <button
                                        onClick={onProceed}
                                        className="ant-button"
                                        disabled={loading}
                                    >
                                        {loading ? "Processing..." : "Proceed"}
                                    </button>
                                )}
                            </div>
                        </div>
                    </div>
                );
            }

            function ActionToast({ message, onClose }) {
                useEffect(() => {
                    const timer = setTimeout(onClose, 5000);
                    return () => clearTimeout(timer);
                }, [onClose]);
                return (
                    <div className="action-toast fixed top-4 right-4 bg-[var(--card-bg)] p-4 rounded shadow-lg">
                        <div className="flex justify-between items-center">
                            <span>{message}</span>
                            <button onClick={onClose} className="ant-button">Close</button>
                        </div>
                    </div>
                );
            }

            function PaginatedTable({ data, headers, rowsPerPage = 5 }) {
                const [currentPage, setCurrentPage] = useState(1);
                const totalPages = Math.ceil(data.length / rowsPerPage);
                const startIndex = (currentPage - 1) * rowsPerPage;
                const currentData = data.slice(startIndex, startIndex + rowsPerPage);

                return (
                    <div>
                        <div className="overflow-x-auto">
                            <table className="w-full">
                                <thead>
                                    <tr className="bg-[var(--card-bg)]">
                                        {headers.map((header, index) => (
                                            <th key={index} className="p-3">{header}</th>
                                        ))}
                                    </tr>
                                </thead>
                                <tbody>
                                    {currentData.map((row, index) => (
                                        <tr key={index} className="border-b border-[var(--accent)]">
                                            {Object.values(row).map((value, i) => (
                                                <td key={i} className="p-3">{value}</td>
                                            ))}
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                        {totalPages > 1 && (
                            <div className="pagination flex justify-center gap-4 mt-4">
                                <button
                                    onClick={() => setCurrentPage(prev => Math.max(prev - 1, 1))}
                                    disabled={currentPage === 1}
                                    className="ant-button"
                                >
                                    Prev
                                </button>
                                <span>{currentPage} / {totalPages}</span>
                                <button
                                    onClick={() => setCurrentPage(prev => Math.min(prev + 1, totalPages))}
                                    disabled={currentPage === totalPages}
                                    className="ant-button"
                                >
                                    Next
                                </button>
                            </div>
                        )}
                    </div>
                );
            }

            function App() {
                const [provider, setProvider] = useState(null);
                const [signer, setSigner] = useState(null);
                const [contract, setContract] = useState(null);
                const [account, setAccount] = useState(null);
                const [currentKing, setCurrentKing] = useState(null);
                const [throneAmount, setThroneAmount] = useState("0");
                const [ethBalance, setEthBalance] = getStateWithPrecision("0");
                const [antBalance, setAntBalance] = getStateWithPrecision("0", 18);
                const [referralBalance, setReferralBalance] = getStateWithPrecision("0");
                const [jackpotBalance, setJackpotBalance] = getStateWithPrecision("0");
                const [isGameActive, setIsGameActive] = useState(false);
                const [kingTimer, setKingTimer] = useState(0);
                const [history, setHistory] = useState([]);
                const [personalStats, setPersonalStats] = useState([]);
                const [notifications, setNotifications] = useState([]);
                const [error, setError] = useState("");
                const [loading, setLoading] = useState(false);
                const [activeSection, setActiveSection] = useState("dashboard");
                const [modalOpen, setModalOpen] = useState(false);
                const [modalAction, setModalAction] = useState(null);
                const [sidebarOpen, setSidebarOpen] = useState(false);
                const [theme, setTheme] = useState("dark");
                const [referralCount, setReferralCount] = useState(0);
                const [chainId, setChainId] = useState(null);
                const [jackpotEligible, setJackpotEligible] = useState(false);
                const [fees, setFees] = useState({ withdrawalFee: 12, jackpotFee: 5, referralFee: 5 }); // Static fees

                function getStateWithPrecision(value, decimals = 18) {
                    const [setValue, setState] = useState(value);
                    return [
                        parseFloat(value).toFixed(3),
                        (newValue) => setState(parseFloat(newValue).toFixed(3))
                    ];
                }

                const getEthereumProvider = () => {
                    if (!window.ethereum) {
                        console.error("No Ethereum provider found. Is MetaMask installed?");
                        return null;
                    }
                    const provider = window.ethereum.isMetaMask ? window.ethereum :
                        window.ethereum.providers?.find(p => p.isMetaMask) || window.ethereum.providers?.[0] || window.ethereum;
                    console.log("Ethereum provider detected:", provider.isMetaMask ? "MetaMask" : "Other");
                    return provider;
                };

                const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

                const connectWallet = async () => {
                    setLoading(true);
                    try {
                        console.log("Initiating wallet connection...");
                        const ethereum = getEthereumProvider();
                        if (!ethereum) {
                            throw new Error("MetaMask not installed or no Ethereum provider found. Please install MetaMask.");
                        }

                        let fetchedChainId = "Unknown";
                        try {
                            let attempts = 0;
                            const maxAttempts = 3;
                            while (attempts < maxAttempts) {
                                try {
                                    fetchedChainId = await ethereum.request({ method: "eth_chainId" });
                                    console.log("Current chain ID:", fetchedChainId);
                                    if (fetchedChainId !== "0xaa01") {
                                        setError("Please switch to MemeCore Testnet (chain ID: 0xaa01).");
                                        await ethereum.request({
                                            method: "wallet_switchEthereumChain",
                                            params: [{ chainId: "0xaa01" }],
                                        });
                                        fetchedChainId = "0xaa01";
                                    }
                                    break;
                                } catch (err) {
                                    attempts++;
                                    console.warn(`Chain ID fetch attempt ${attempts} failed:`, err);
                                    if (attempts === maxAttempts) {
                                        console.warn("Could not fetch chain ID, proceeding anyway.");
                                        fetchedChainId = "Unknown (fetch failed)";
                                    }
                                    await delay(1000);
                                }
                            }
                        } catch (err) {
                            console.warn("Chain ID fetch or switch failed, continuing connection:", err);
                            setError("Failed to switch to MemeCore Testnet: " + (err.message || "Unknown error"));
                        }
                        setChainId(fetchedChainId);

                        console.log("Requesting accounts...");
                        let accounts;
                        try {
                            accounts = await ethereum.request({ method: "eth_requestAccounts" });
                            console.log("Accounts received:", accounts);
                        } catch (err) {
                            throw new Error("Failed to request accounts: " + (err.message || err.code || "User rejected or MetaMask is locked"));
                        }
                        if (!accounts?.length) {
                            throw new Error("No accounts found. Please ensure MetaMask is unlocked and has accounts.");
                        }

                        console.log("Initializing provider and signer...");
                        let provider, signer, address;
                        try {
                            provider = new ethers.providers.Web3Provider(ethereum);
                            signer = provider.getSigner();
                            address = await signer.getAddress();
                            console.log("Connected address:", address);
                        } catch (err) {
                            throw new Error("Failed to initialize provider or signer: " + (err.message || "Unknown error"));
                        }

                        console.log("Checking contracts.js availability...");
                        if (!window.CORE_ADDRESS || !window.CORE_ABI) {
                            throw new Error("Contract configuration missing. Ensure contracts.js is loaded with valid CORE_ADDRESS and CORE_ABI.");
                        }

                        console.log("Initializing contract on chain:", fetchedChainId);
                        let contract;
                        try {
                            contract = new ethers.Contract(window.CORE_ADDRESS, window.CORE_ABI, signer);
                            await contract.currentKing();
                            console.log("Contract initialized successfully on chain:", fetchedChainId);
                        } catch (err) {
                            console.error("Contract initialization failed:", err);
                            throw new Error(`Contract not available on this chain (ID: ${fetchedChainId}). Please ensure CORE_ADDRESS (${window.CORE_ADDRESS}) is correct and deployed on MemeCore Testnet (chain ID: 0xaa01).`);
                        }

                        setProvider(provider);
                        setSigner(signer);
                        setContract(contract);
                        setAccount(address);
                        setError(`Connected to chain ${fetchedChainId}. Wallet connected successfully.`);
                        localStorage.setItem("connectedWallet", address);
                        console.log("Wallet connected successfully. Updating state...");
                        await updateState(contract, address);
                    } catch (err) {
                        console.error("Wallet connection failed:", err);
                        setError(`Connection failed: ${err.message || "Unknown error occurred during connection."}`);
                    } finally {
                        setLoading(false);
                    }
                };

                const disconnectWallet = () => {
                    console.log("Disconnecting wallet...");
                    setProvider(null);
                    setSigner(null);
                    setContract(null);
                    setAccount(null);
                    setChainId(null);
                    localStorage.removeItem("connectedWallet");
                    setError("Wallet disconnected.");
                };

                const updateState = async (contract, address) => {
                    if (!contract || !address) {
                        console.warn("Missing contract or address for state update.");
                        setError("Cannot update state: Missing contract or account.");
                        return;
                    }
                    try {
                        console.log("Updating kingdom state...");
                        const king = await contract.currentKing();
                        const throne = await contract.throneAmount();
                        const ethBal = await contract.dashboard(address);
                        const antBal = await contract.passiveIncome(address);
                        const referralBal = await contract.referralEarnings(address);
                        const jackpotBal = await contract.jackpotBalance();
                        const active = await contract.isGameActive();
                        const kingStart = await contract.kingStartTime();
                        const [referrer, count, balance] = await contract.getReferralStats(address);
                        const [isEligible, jackpotAmount] = await contract.getJackpotEligibility();

                        setCurrentKing(king);
                        setThroneAmount(ethers.utils.formatEther(throne));
                        setEthBalance(ethers.utils.formatEther(ethBal));
                        setAntBalance(ethers.utils.formatUnits(antBal, 18));
                        setReferralBalance(ethers.utils.formatEther(referralBal));
                        setJackpotBalance(ethers.utils.formatEther(jackpotAmount));
                        setIsGameActive(active);
                        setKingTimer(active ? Math.floor((Date.now() / 1000) - kingStart.toNumber()) : 0);
                        setReferralCount(count.toNumber());
                        setFees({ withdrawalFee: 12, jackpotFee: 5, referralFee: 5 }); // Static fees
                        setJackpotEligible(isEligible);
                        await updateHistory(contract);
                        await updatePersonalStats(contract, address);
                        console.log("State updated successfully:", {
                            king,
                            throne: ethers.utils.formatEther(throne),
                            ethBalance: ethers.utils.formatEther(ethBal),
                            antBalance: ethers.utils.formatUnits(antBal, 18),
                            jackpotBalance: ethers.utils.formatEther(jackpotAmount),
                            isGameActive: active
                        });
                    } catch (err) {
                        console.error("State update failed:", err);
                        setError("Can't load kingdom data: " + (err.message || "Failed to fetch contract data"));
                    }
                };

                const updateHistory = async (contract) => {
                    if (!contract) {
                        setError("Cannot update history: Missing contract.");
                        return;
                    }
                    try {
                        console.log("Updating history...");
                        const reign = await contract.getLastReign();
                        console.log("Last reign:", reign);
                        const isEmptyReign = reign[0] === "0x0000000000000000000000000000000000000000" && reign[1].toNumber() === 0;
                        const historyData = isEmptyReign ? [] : [{
                            king: reign[0] === "0x0000000000000000000000000000000000000000" ? "None" : reign[0].slice(0, 6) + "..." + reign[0].slice(-4),
                            startTime: reign[1].toNumber() ? new Date(reign[1].toNumber() * 1000).toLocaleString() : "N/A",
                            endTime: reign[2].toNumber() ? new Date(reign[2].toNumber() * 1000).toLocaleString() : "Ongoing",
                            throneAmount: parseFloat(ethers.utils.formatEther(reign[3])).toFixed(3),
                            ethEarnings: parseFloat(ethers.utils.formatEther(reign[4])).toFixed(3),
                            antEarnings: parseFloat(ethers.utils.formatUnits(reign[5], 18)).toFixed(3)
                        }];
                        setHistory(historyData);
                        console.log("History updated:", historyData);
                        if (historyData.length === 0) {
                            setError("No kingdom history yet. Become the first King to start a reign!");
                        }
                    } catch (err) {
                        console.error("History update failed:", err);
                        setError("Can't load history: " + (err.message || "Failed to fetch reign data"));
                    }
                };

                const updatePersonalStats = async (contract, address) => {
                    if (!contract || !address) {
                        setError("Cannot update personal stats: Missing contract or account.");
                        return;
                    }
                    try {
                        console.log("Updating personal stats for", address);
                        const activities = [];
                        const filterNewKing = contract.filters.NewKing(address);
                        const filterDissolve = contract.filters.KingdomDissolved(null, address);
                        const filterJackpot = contract.filters.JackpotAwarded(address, null);
                        const filterWithdrawn = contract.filters.Withdrawn(address, null, null, null, null, null);
                        const filterReferred = contract.filters.Referred(address, null);
                        let eventsNewKing = [], eventsDissolve = [], eventsJackpot = [], eventsWithdrawn = [], eventsReferred = [];
                        try {
                            eventsNewKing = await contract.queryFilter(filterNewKing);
                            eventsDissolve = await contract.queryFilter(filterDissolve);
                            eventsJackpot = await contract.queryFilter(filterJackpot);
                            eventsWithdrawn = await contract.queryFilter(filterWithdrawn);
                            eventsReferred = await contract.queryFilter(filterReferred);
                        } catch (err) {
                            console.warn("Event query failed, possibly due to limited chain history:", err);
                            setError("Failed to fetch personal activities. Chain history may be limited.");
                        }

                        eventsNewKing.forEach(event => {
                            if (event.args?.throneAmount && event.args?.timestamp) {
                                activities.push({
                                    activity: `Became King with ${parseFloat(ethers.utils.formatEther(event.args.throneAmount)).toFixed(3)} ETH`,
                                    timestamp: new Date(event.args.timestamp.toNumber() * 1000).toLocaleString(),
                                    ethInvolved: parseFloat(ethers.utils.formatEther(event.args.throneAmount)).toFixed(3)
                                });
                            }
                        });
                        eventsDissolve.forEach(event => {
                            if (event.args?.throneAmount && event.args?.timestamp) {
                                activities.push({
                                    activity: `Dissolved kingdom with ${parseFloat(ethers.utils.formatEther(event.args.throneAmount)).toFixed(3)} ETH`,
                                    timestamp: new Date(event.args.timestamp.toNumber() * 1000).toLocaleString(),
                                    ethInvolved: parseFloat(ethers.utils.formatEther(event.args.throneAmount)).toFixed(3)
                                });
                            }
                        });
                        eventsJackpot.forEach(event => {
                            if (event.args?.amount && event.args?.timestamp) {
                                activities.push({
                                    activity: `Won jackpot of ${parseFloat(ethers.utils.formatEther(event.args.amount)).toFixed(3)} ETH`,
                                    timestamp: new Date(event.args.timestamp.toNumber() * 1000).toLocaleString(),
                                    ethInvolved: parseFloat(ethers.utils.formatEther(event.args.amount)).toFixed(3)
                                });
                            }
                        });
                        eventsWithdrawn.forEach(event => {
                            if (event.args?.amount && event.args?.timestamp && event.args?.assetType) {
                                activities.push({
                                    activity: `Withdrew ${parseFloat(ethers.utils.formatEther(event.args.amount)).toFixed(3)} ${event.args.assetType}`,
                                    timestamp: new Date(event.args.timestamp.toNumber() * 1000).toLocaleString(),
                                    ethInvolved: event.args.assetType === "ETH" || event.args.assetType === "Referral" ? parseFloat(ethers.utils.formatEther(event.args.amount)).toFixed(3) : "0"
                                });
                            }
                        });
                        eventsReferred.forEach(event => {
                            if (event.args?.timestamp) {
                                activities.push({
                                    activity: `Referred a new player`,
                                    timestamp: new Date(event.args.timestamp.toNumber() * 1000).toLocaleString(),
                                    ethInvolved: "0"
                                });
                            }
                        });

                        activities.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                        setPersonalStats(activities.slice(0, 5));
                        console.log("Personal stats updated:", activities.slice(0, 5));
                        if (activities.length === 0) {
                            setError("No personal activities yet. Try becoming King, dissolving the kingdom, or winning a jackpot!");
                        }
                    } catch (err) {
                        console.error("Personal stats update failed:", err);
                        setError("Can't load personal stats: " + (err.message || "Failed to fetch event data"));
                    }
                };

                const handleBecomeKing = async () => {
                    if (!contract || !signer) {
                        setError("Connect wallet first.");
                        return;
                    }
                    setLoading(true);
                    try {
                        console.log("Becoming King with amount:", isGameActive ? throneAmount : "5 ETH");
                        const amount = isGameActive ? ethers.utils.parseEther(throneAmount.toString()) : ethers.utils.parseEther("5");
                        const urlParams = new URLSearchParams(window.location.search);
                        const referrer = urlParams.get("referrer") || "0x0000000000000000000000000000000000000000";
                        if (!ethers.utils.isAddress(referrer)) {
                            console.warn("Invalid referrer address:", referrer);
                            setError("Invalid referrer address provided.");
                            setLoading(false);
                            setModalOpen(false);
                            return;
                        }
                        const tx = await contract.becomeKing(referrer, { value: amount });
                        console.log("Become King TX sent:", tx.hash);
                        await tx.wait();
                        setNotifications(prev => [...prev, { message: "You are now the King!", timestamp: Date.now() }]);
                        await updateState(contract, account);
                    } catch (err) {
                        console.error("Become King failed:", err);
                        const errorMessage = err.reason || err.message || "Transaction failed";
                        if (errorMessage.includes("Current King cannot become King")) {
                            setError("You are already the King.");
                        } else if (errorMessage.includes("Payment required")) {
                            setError("ETH payment is required to become King.");
                        } else if (errorMessage.includes("Must pay")) {
                            setError(`Incorrect ETH amount sent. Required: ${isGameActive ? parseFloat(throneAmount).toFixed(3) : "5.000"} ETH`);
                        } else if (errorMessage.includes("Referrer already set")) {
                            setError("Referrer already set for this address.");
                        } else {
                            setError(`Failed to become King: ${errorMessage}`);
                        }
                    } finally {
                        setLoading(false);
                        setModalOpen(false);
                    }
                };

                const handleDissolveKingdom = async () => {
                    if (!contract || !signer) {
                        setError("Connect wallet first.");
                        return;
                    }
                    setLoading(true);
                    try {
                        console.log("Dissolving kingdom with amount:", throneAmount);
                        const amount = ethers.utils.parseEther(throneAmount.toString());
                        const tx = await contract.dissolveKingdom({ value: amount });
                        console.log("Dissolve Kingdom TX sent:", tx.hash);
                        await tx.wait();
                        setNotifications(prev => [...prev, { message: "Kingdom dissolved!", timestamp: Date.now() }]);
                        await updateState(contract, account);
                    } catch (err) {
                        console.error("Dissolve failed:", err);
                        const errorMessage = err.reason || err.message || "Transaction failed";
                        if (errorMessage.includes("No kingdom to dissolve")) {
                            setError("No active kingdom to dissolve.");
                        } else if (errorMessage.includes("Current King cannot dissolve")) {
                            setError("Kings cannot dissolve their own kingdom.");
                        } else if (errorMessage.includes("Must pay throne amount")) {
                            setError(`Incorrect ETH amount sent. Required: ${parseFloat(throneAmount).toFixed(3)} ETH`);
                        } else {
                            setError(`Dissolve failed: ${errorMessage}`);
                        }
                    } finally {
                        setLoading(false);
                        setModalOpen(false);
                    }
                };

                const handleResetJackpot = async () => {
                    if (!contract || !signer) {
                        setError("Connect wallet first.");
                        return;
                    }
                    setLoading(true);
                    try {
                        console.log("Resetting jackpot...");
                        const tx = await contract.resetJackpot();
                        console.log("Reset Jackpot TX sent:", tx.hash);
                        await tx.wait();
                        setNotifications(prev => [...prev, { message: "Jackpot claimed!", timestamp: Date.now() }]);
                        await updateState(contract, account);
                    } catch (err) {
                        console.error("Reset jackpot failed:", err);
                        const errorMessage = err.reason || err.message || "Transaction failed";
                        if (errorMessage.includes("No active game")) {
                            setError("No active game to claim jackpot.");
                        } else if (errorMessage.includes("No King")) {
                            setError("No King present to claim jackpot.");
                        } else if (errorMessage.includes("King not eligible yet")) {
                            setError("King's reign is less than 3 minutes.");
                        } else {
                            setError(`Jackpot claim failed: ${errorMessage}`);
                        }
                    } finally {
                        setLoading(false);
                    }
                };

                const handleWithdrawETH = async () => {
                    if (!contract || !signer) {
                        setError("Connect wallet first.");
                        return;
                    }
                    setLoading(true);
                    try {
                        console.log("Withdrawing ETH...");
                        const tx = await contract.withdrawETH();
                        console.log("Withdraw ETH TX sent:", tx.hash);
                        await tx.wait();
                        setError(`ETH withdrawn! ${fees.withdrawalFee + fees.jackpotFee + fees.referralFee}% fee applied.`);
                        await updateState(contract, account);
                    } catch (err) {
                        console.error("Withdraw ETH failed:", err);
                        const errorMessage = err.reason || err.message || "Transaction failed";
                        if (errorMessage.includes("No ETH to withdraw")) {
                            setError("No ETH available to withdraw.");
                        } else {
                            setError(`Can't withdraw ETH: ${errorMessage}`);
                        }
                    } finally {
                        setLoading(false);
                    }
                };

                const handleWithdrawReferralEarnings = async () => {
                    if (!contract || !signer) {
                        setError("Connect wallet first.");
                        return;
                    }
                    setLoading(true);
                    try {
                        console.log("Withdrawing referral earnings...");
                        const tx = await contract.withdrawReferralEarnings();
                        console.log("Withdraw Referral TX sent:", tx.hash);
                        await tx.wait();
                        setError("Referral ETH withdrawn!");
                        await updateState(contract, account);
                    } catch (err) {
                        console.error("Withdraw referral failed:", err);
                        const errorMessage = err.reason || err.message || "Transaction failed";
                        if (errorMessage.includes("No referral earnings to withdraw")) {
                            setError("No referral earnings to withdraw.");
                        } else {
                            setError(`Can't withdraw referral: ${errorMessage}`);
                        }
                    } finally {
                        setLoading(false);
                    }
                };

                const handleWithdrawTokens = async () => {
                    if (!contract || !signer) {
                        setError("Connect wallet first.");
                        return;
                    }
                    setLoading(true);
                    try {
                        console.log("Withdrawing ANT tokens...");
                        const tx = await contract.withdrawTokens();
                        console.log("Withdraw Tokens TX sent:", tx.hash);
                        await tx.wait();
                        setError("ANT tokens withdrawn!");
                        await updateState(contract, account);
                    } catch (err) {
                        console.error("Withdraw tokens failed:", err);
                        const errorMessage = err.reason || err.message || "Transaction failed";
                        if (errorMessage.includes("No tokens to withdraw")) {
                            setError("No ANT tokens available to withdraw.");
                        } else if (errorMessage.includes("Insufficient pool balance")) {
                            setError("Contract has insufficient ANT balance.");
                        } else {
                            setError(`Can't withdraw ANT: ${errorMessage}`);
                        }
                    } finally {
                        setLoading(false);
                    }
                };

                const toggleTheme = () => {
                    const newTheme = theme === "dark" ? "light" : "dark";
                    setTheme(newTheme);
                    document.body.classList.toggle("light-theme", newTheme === "light");
                    console.log("Theme switched to:", newTheme);
                };

                const openModal = (action) => {
                    setModalAction(action);
                    setModalOpen(true);
                };

                const getReferralLink = () => {
                    if (!account) return "";
                    return `${window.location.origin}?referrer=${account}`;
                };

                const copyReferralLink = () => {
                    try {
                        navigator.clipboard.writeText(getReferralLink());
                        setError("Referral link copied!");
                    } catch (err) {
                        console.error("Copy referral link failed:", err);
                        setError("Failed to copy referral link: " + (err.message || "Clipboard error"));
                    }
                };

                const isCurrentKing = account && currentKing && account.toLowerCase() === currentKing.toLowerCase();

                useEffect(() => {
                    console.log("Initial setup...");
                    console.log("CORE_ADDRESS:", window.CORE_ADDRESS || "Not set");
                    if (!window.CORE_ADDRESS || !window.CORE_ABI) {
                        setError("Contract configuration missing. Ensure contracts.js is loaded.");
                        return;
                    }
                    const savedAddress = localStorage.getItem("connectedWallet");
                    if (savedAddress && !account) {
                        const ethereum = getEthereumProvider();
                        if (ethereum) {
                            try {
                                console.log("Restoring wallet for address:", savedAddress);
                                const provider = new ethers.providers.Web3Provider(ethereum);
                                const signer = provider.getSigner();
                                const contract = new ethers.Contract(window.CORE_ADDRESS, window.CORE_ABI, signer);
                                setProvider(provider);
                                setSigner(signer);
                                setContract(contract);
                                setAccount(savedAddress);
                                updateState(contract, savedAddress);
                            } catch (err) {
                                console.error("Saved wallet setup failed:", err);
                                setError("Failed to restore wallet: " + (err.message || "Unable to reconnect"));
                            }
                        } else {
                            console.warn("No Ethereum provider for saved wallet.");
                            setError("MetaMask not detected for saved wallet. Please reconnect.");
                        }
                    }
                }, []);

                useEffect(() => {
                    if (isGameActive) {
                        const interval = setInterval(() => {
                            setKingTimer(prev => prev + 1);
                        }, 1000);
                        return () => clearInterval(interval);
                    }
                }, [isGameActive]);

                useEffect(() => {
                    if (error) {
                        const timer = setTimeout(() => setError(""), 15000);
                        return () => clearTimeout(timer);
                    }
                }, [error]);

                useEffect(() => {
                    const ethereum = getEthereumProvider();
                    if (!ethereum) {
                        setError("No Ethereum provider detected. Please install MetaMask.");
                        return;
                    }
                    const handleAccountsChanged = (accounts) => {
                        console.log("Accounts changed:", accounts);
                        if (accounts.length > 0) {
                            setAccount(accounts[0]);
                            localStorage.setItem("connectedWallet", accounts[0]);
                            if (contract) updateState(contract, accounts[0]);
                        } else {
                            disconnectWallet();
                        }
                    };
                    const handleChainChanged = (chainId) => {
                        console.log("Chain changed to:", chainId);
                        setChainId(chainId);
                        if (account) {
                            const provider = new ethers.providers.Web3Provider(ethereum);
                            const signer = provider.getSigner();
                            try {
                                const newContract = new ethers.Contract(window.CORE_ADDRESS, window.CORE_ABI, signer);
                                setProvider(provider);
                                setSigner(signer);
                                setContract(newContract);
                                updateState(newContract, account);
                                setError(`Switched to chain ${chainId}. Contract loaded successfully.`);
                            } catch (err) {
                                console.error("Contract reinitialization failed on chain change:", err);
                                setError(`Contract not available on chain ${chainId}. Please switch to MemeCore Testnet (chain ID: 0xaa01).`);
                                setContract(null);
                            }
                        }
                    };

                    try {
                        ethereum.on("accountsChanged", handleAccountsChanged);
                        ethereum.on("chainChanged", handleChainChanged);
                    } catch (err) {
                        console.error("Ethereum listener setup failed:", err);
                        setError("Failed to set up wallet listeners.");
                    }

                    return () => {
                        try {
                            ethereum.removeListener("accountsChanged", handleAccountsChanged);
                            ethereum.removeListener("chainChanged", handleChainChanged);
                        } catch (err) {
                            console.warn("Failed to remove Ethereum listeners:", err);
                        }
                    };
                }, [contract, account]);

                useEffect(() => {
                    if (notifications.length > 0) {
                        const timer = setTimeout(() => {
                            setNotifications(prev => prev.slice(1));
                        }, 5000);
                        return () => clearTimeout(timer);
                    }
                }, [notifications]);

                const getButtonTooltip = (action) => {
                    if (loading) return "Action in progress.";
                    if (!contract || !signer) return "Connect wallet or switch to MemeCore Testnet.";
                    if (isCurrentKing && action !== "resetJackpot") return "You are the King.";
                    if (action === "dissolveKingdom" && !isGameActive) return "No active kingdom.";
                    if (action === "resetJackpot" && !jackpotEligible) return "King's reign is less than 3 minutes.";
                    return "";
                };

                return (
                    <ErrorBoundary>
                        <div className="relative">
                            <button
                                onClick={() => setSidebarOpen(!sidebarOpen)}
                                className="sidebar-toggle ant-button fixed top-4 left-4 z-50"
                            >
                                ☰
                            </button>
                            <div className={`sidebar ${sidebarOpen ? 'open' : ''} fixed top-0 left-0 h-full bg-[var(--card-bg)] w-64 z-40 transition-transform transform ${sidebarOpen ? 'translate-x-0' : '-translate-x-full'}`}>
                                <div className="p-4">
                                    <h1 className="text-2xl font-bold text-[var(--primary)] mb-6">Ant Kingdom</h1>
                                    <nav className="flex flex-col gap-2">
                                        <button onClick={() => { setActiveSection("dashboard"); setSidebarOpen(false); }} className="ant-button text-left">🏠 Dashboard</button>
                                        <button onClick={() => { setActiveSection("jackpot"); setSidebarOpen(false); }} className="ant-button text-left">💰 Jackpot</button>
                                        <button onClick={() => { setActiveSection("history"); setSidebarOpen(false); }} className="ant-button text-left">📜 History</button>
                                        <button onClick={() => { setActiveSection("referral"); setSidebarOpen(false); }} className="ant-button text-left">🤝 Referral</button>
                                        <button onClick={() => { setActiveSection("faq"); setSidebarOpen(false); }} className="ant-button text-left">❓ FAQ</button>
                                        <button onClick={() => { setActiveSection("miniapps"); setSidebarOpen(false); }} className="ant-button text-left">🎮 Mini Games</button>
                                        <button onClick={toggleTheme} className="ant-button text-left">
                                            {theme === "dark" ? "🌞 Light Theme" : "🌙 Dark Theme"}
                                        </button>
                                        {account ? (
                                            <>
                                                <button className="ant-button" disabled={loading}>
                                                    {account.slice(0, 6)}...{account.slice(-4)} (Chain: {chainId || "Unknown"})
                                                </button>
                                                <button onClick={() => { disconnectWallet(); setSidebarOpen(false); }} className="ant-button">
                                                    Disconnect
                                                </button>
                                            </>
                                        ) : (
                                            <button onClick={() => { connectWallet(); setSidebarOpen(false); }} className="ant-button" disabled={loading}>
                                                {loading ? "Connecting..." : "Connect Wallet"}
                                            </button>
                                        )}
                                    </nav>
                                </div>
                            </div>

                            <div className="hero-section text-center py-16 bg-gradient-to-b from-[var(--background)] to-[var(--card-bg)]">
                                <h1 className="text-5xl font-bold text-[var(--primary)] mb-4">Ant Kingdom</h1>
                                <p className="text-lg max-w-2xl mx-auto">
                                    Rule the kingdom, seize the jackpot, and earn through referrals!
                                </p>
                                {!account && (
                                    <button
                                        onClick={connectWallet}
                                        className="ant-button mt-6 px-6 py-3 text-lg"
                                        disabled={loading}
                                    >
                                        {loading ? "Connecting..." : "Connect Wallet"}
                                    </button>
                                )}
                            </div>

                            {error && (
                                <div className="action-toast fixed top-4 right-4 bg-[var(--card-bg)] p-4 rounded shadow-lg">
                                    <span>{error}</span>
                                    <button onClick={() => setError("")} className="ant-button ml-4">Close</button>
                                </div>
                            )}

                            {notifications.map((notif, index) => (
                                <ActionToast
                                    key={index}
                                    message={notif.message}
                                    onClose={() => setNotifications(prev => prev.filter((_, i) => i !== index))}
                                />
                            ))}

                            {activeSection === "dashboard" && (
                                <div className="ant-container py-8 px-4 max-w-6xl mx-auto">
                                    <h2 className="text-3xl font-bold text-[var(--primary)] mb-6">Dashboard</h2>
                                    {chainId && (
                                        <div className="ant-card mb-6 p-6 rounded-lg bg-[var(--card-bg)] shadow">
                                            <h3 className="text-xl font-semibold mb-4 text-center">Debug Info</h3>
                                            <p className="text-center text-2xl text-[var(--primary)]">
                                                🔗 Chain ID: {chainId}
                                            </p>
                                            <p className="text-center text-sm">
                                                Contract: {window.CORE_ADDRESS || "Not set"}
                                            </p>
                                        </div>
                                    )}
                                    {currentKing && currentKing !== "0x0000000000000000000000000000000000000000" && (
                                        <div className="ant-card mb-6 p-6 rounded-lg bg-[var(--card-bg)] shadow animate-[glow_2s_ease-in-out_infinite]">
                                            <h3 className="text-xl font-semibold mb-4 text-center">Hail the King</h3>
                                            <p className="text-center text-2xl text-[var(--primary)]">
                                                👑 {currentKing.slice(0, 6)}...{currentKing.slice(-4)}
                                            </p>
                                            <p className="text-center mt-2 italic">The kingdom thrives!</p>
                                        </div>
                                    )}
                                    <div className="ant-card mb-6 p-6 rounded-lg bg-[var(--card-bg)] shadow">
                                        <h3 className="text-xl font-semibold mb-4">Your Stats</h3>
                                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                            <div className="ant-card p-4 bg-[var(--background)] rounded">
                                                <h4 className="text-lg font-semibold text-[var(--primary)]">ETH Balance</h4>
                                                <p className="text-2xl">💰 {ethBalance} ETH</p>
                                            </div>
                                            <div className="ant-card p-4 bg-[var(--background)] rounded">
                                                <h4 className="text-lg font-semibold text-[var(--primary)]">ANT Balance</h4>
                                                <p className="text-2xl">🐜 {antBalance} ANT</p>
                                            </div>
                                            <div className="ant-card p-4 bg-[var(--background)] rounded">
                                                <h4 className="text-lg font-semibold text-[var(--primary)]">Referral Earnings</h4>
                                                <p className="text-2xl">🤝 {referralBalance} ETH</p>
                                            </div>
                                        </div>
                                        <div className="flex flex-wrap gap-4 mt-4">
                                            <button onClick={handleWithdrawETH} className="ant-button" disabled={loading || parseFloat(ethBalance) <= 0 || !contract}>
                                                Withdraw ETH
                                            </button>
                                            <button onClick={handleWithdrawReferralEarnings} className="ant-button" disabled={loading || parseFloat(referralBalance) <= 0 || !contract}>
                                                Withdraw Referral ETH
                                            </button>
                                            <button onClick={handleWithdrawTokens} className="ant-button" disabled={loading || parseFloat(antBalance) <= 0 || !contract}>
                                                Withdraw ANT
                                            </button>
                                        </div>
                                    </div>
                                    <div className="ant-card mb-6 p-6 rounded-lg bg-[var(--card-bg)] shadow">
                                        <h3 className="text-xl font-semibold mb-4">Actions</h3>
                                        <div className="flex flex-wrap gap-4">
                                            <button
                                                onClick={() => openModal("becomeKing")}
                                                className="ant-button"
                                                disabled={loading || isCurrentKing || !contract || !signer}
                                                title={getButtonTooltip("becomeKing")}
                                            >
                                                Become King
                                            </button>
                                            <button
                                                onClick={() => openModal("dissolveKingdom")}
                                                className="ant-button"
                                                disabled={loading || !isGameActive || isCurrentKing || !contract || !signer}
                                                title={getButtonTooltip("dissolveKingdom")}
                                            >
                                                Dissolve Kingdom
                                            </button>
                                        </div>
                                    </div>
                                    <div className="ant-card mb-6 p-6 rounded-lg bg-[var(--card-bg)] shadow">
                                        <h3 className="text-xl font-semibold mb-4">Jackpot</h3>
                                        <div className="ant-card p-4 bg-[var(--background)] rounded">
                                            <h4 className="text-lg font-semibold text-[var(--primary)]">Current Jackpot</h4>
                                            <p className="text-2xl">💰 {jackpotBalance} ETH</p>
                                        </div>
                                        {isCurrentKing && (
                                            <div className="mt-4">
                                                <button
                                                    onClick={handleResetJackpot}
                                                    className="ant-button"
                                                    disabled={loading || !jackpotEligible || !contract || !signer}
                                                    title={getButtonTooltip("resetJackpot")}
                                                >
                                                    Claim Jackpot
                                                </button>
                                            </div>
                                        )}
                                    </div>
                                    <div className="ant-card p-6 rounded-lg bg-[var(--card-bg)] shadow">
                                        <h3 className="text-xl font-semibold mb-4">Kingdom Stats</h3>
                                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                            <div className="ant-card p-4 bg-[var(--background)] rounded">
                                                <h4 className="text-lg font-semibold text-[var(--primary)]">Throne Amount</h4>
                                                <p>{parseFloat(throneAmount).toFixed(3)} ETH</p>
                                            </div>
                                            <div className="ant-card p-4 bg-[var(--background)] rounded">
                                                <h4 className="text-lg font-semibold text-[var(--primary)]">Status</h4>
                                                <p>{isGameActive ? "Active" : "Inactive"}</p>
                                            </div>
                                            <div className="ant-card p-4 bg-[var(--background)] rounded">
                                                <h4 className="text-lg font-semibold text-[var(--primary)]">King’s Reign</h4>
                                                <p>{kingTimer ? `${Math.floor(kingTimer / 3600)}h ${Math.floor((kingTimer % 3600) / 60)}m ${kingTimer % 60}s` : "N/A"}</p>
                                            </div>
                                            <div className="ant-card p-4 bg-[var(--background)] rounded">
                                                <h4 className="text-lg font-semibold text-[var(--primary)]">Fees</h4>
                                                <p>{fees.withdrawalFee}% owner, {fees.jackpotFee}% jackpot, {fees.referralFee}% referral</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            )}

                            {activeSection === "jackpot" && (
                                <div className="ant-container py-8 px-4 max-w-6xl mx-auto">
                                    <h2 className="text-3xl font-bold text-[var(--primary)] mb-6">Jackpot</h2>
                                    <div className="ant-card mb-6 p-6 rounded-lg bg-[var(--card-bg)] shadow">
                                        <h3 className="text-xl font-semibold mb-4">Jackpot Status</h3>
                                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                            <div className="ant-card p-4 bg-[var(--background)] rounded">
                                                <h4 className="text-lg font-semibold text-[var(--primary)]">Current Jackpot</h4>
                                                <p className="text-2xl">💰 {jackpotBalance} ETH</p>
                                            </div>
                                            <div className="ant-card p-4 bg-[var(--background)] rounded">
                                                <h4 className="text-lg font-semibold text-[var(--primary)]">Eligibility</h4>
                                                <p>{jackpotEligible ? "King eligible after 3 minutes" : "King not yet eligible (less than 3 minutes)"}</p>
                                            </div>
                                        </div>
                                        {isCurrentKing && (
                                            <div className="mt-4">
                                                <button
                                                    onClick={handleResetJackpot}
                                                    className="ant-button"
                                                    disabled={loading || !jackpotEligible || !contract || !signer}
                                                    title={getButtonTooltip("resetJackpot")}
                                                >
                                                    Claim Jackpot
                                                </button>
                                            </div>
                                        )}
                                        <p className="mt-4">
                                            The jackpot is awarded to the current King after a 3-minute reign, either when claimed or when a new King takes the throne.
                                        </p>
                                    </div>
                                </div>
                            )}

                            {activeSection === "history" && (
                                <div className="ant-container py-8 px-4 max-w-6xl mx-auto">
                                    <h2 className="text-3xl font-bold text-[var(--primary)] mb-6">History</h2>
                                    <div className="ant-card mb-6 p-6 rounded-lg bg-[var(--card-bg)] shadow">
                                        <h3 className="text-xl font-semibold mb-4">Last King</h3>
                                        {history.length === 0 ? (
                                            <p>No kingdom history yet. Become the first King to start a reign!</p>
                                        ) : (
                                            <PaginatedTable
                                                data={history}
                                                headers={["King", "Start Time", "End Time", "Throne Amount (ETH)", "ETH Earnings", "ANT Earnings"]}
                                            />
                                        )}
                                    </div>
                                    <div className="ant-card p-6 rounded-lg bg-[var(--card-bg)] shadow">
                                        <h3 className="text-xl font-semibold mb-4">Your Activity</h3>
                                        {personalStats.length === 0 ? (
                                            <p>No personal activities yet. Try becoming King, dissolving the kingdom, or winning a jackpot!</p>
                                        ) : (
                                            <PaginatedTable
                                                data={personalStats}
                                                headers={["Activity", "Timestamp", "ETH Involved"]}
                                            />
                                        )}
                                    </div>
                                </div>
                            )}

                            {activeSection === "referral" && (
                                <div className="ant-container py-8 px-4 max-w-6xl mx-auto">
                                    <h2 className="text-3xl font-bold text-[var(--primary)] mb-6">Referral Program</h2>
                                    <div className="ant-card p-6 rounded-lg bg-[var(--card-bg)] shadow">
                                        <h3 className="text-xl font-semibold mb-4">Your Stats</h3>
                                        <p><strong>Earnings:</strong> {referralBalance} ETH</p>
                                        <p><strong>Referrals:</strong> {referralCount}</p>
                                        {account ? (
                                            <div className="mt-4">
                                                <p><strong>Your Link:</strong></p>
                                                <input
                                                    type="text"
                                                    value={getReferralLink()}
                                                    readOnly
                                                    className="w-full p-2 mt-2 bg-[var(--card-bg)] text-[var(--text)] border border-[var(--accent)] rounded"
                                                />
                                                <button onClick={copyReferralLink} className="ant-button mt-2">
                                                    Copy Link
                                                </button>
                                            </div>
                                        ) : (
                                            <p className="mt-4">Connect wallet to get your link.</p>
                                        )}
                                        <p className="mt-4">
                                            Earn 5% of referred users’ ETH withdrawals, no fees. Share your link to invite others!
                                        </p>
                                    </div>
                                </div>
                            )}

                            {activeSection === "faq" && (
                                <div className="ant-container py-8 px-4 max-w-6xl mx-auto">
                                    <h2 className="text-3xl font-bold text-[var(--primary)] mb-6">FAQ</h2>
                                    <div className="ant-card mb-6 p-6 rounded-lg bg-[var(--card-bg)] shadow">
                                        <h3 className="text-xl font-semibold mb-4">About Ant Kingdom</h3>
                                        <p>
                                            Ant Kingdom is a decentralized game on the MemeCore Testnet where players compete to become the King of the colony by paying ETH to claim the throne. The game offers opportunities to earn ANT tokens, claim jackpots, and gain referral rewards.
                                        </p>
                                    </div>
                                    <div className="ant-card mb-6 p-6 rounded-lg bg-[var(--card-bg)] shadow">
                                        <h3 className="text-xl font-semibold mb-4">How to Play</h3>
                                        <ul className="list-disc pl-6">
                                            <li><strong>Become King:</strong> Pay the current throne amount (initially 5 ETH, then 42.86% higher each time) to become the King. The new throne amount is set to your payment multiplied by 1.4286.</li>
                                            <li><strong>Earn Rewards:</strong> As King, earn 100 ANT tokens daily and become eligible for the jackpot after 3 minutes.</li>
                                            <li><strong>Dissolve Kingdom:</strong> Pay the current throne amount to dissolve the kingdom, splitting the payment 50% to the jackpot and 50% to the contract owner.</li>
                                            <li><strong>Jackpot:</strong> The King can claim the jackpot after a 3-minute reign, or it’s awarded when a new King takes over.</li>
                                            <li><strong>Withdrawals:</strong> Withdraw ETH (12% owner fee, 5% jackpot fee, 5% referral fee), ANT tokens, or referral earnings.</li>
                                            <li><strong>Referrals:</strong> Share your referral link to earn 5% of referred users’ ETH withdrawals.</li>
                                        </ul>
                                    </div>
                                    <div className="ant-card p-6 rounded-lg bg-[var(--card-bg)] shadow">
                                        <h3 className="text-xl font-semibold mb-4">Frequently Asked Questions</h3>
                                        <div className="space-y-4">
                                            <div>
                                                <p><strong>What is the initial throne amount?</strong></p>
                                                <p>The first King pays exactly 5 ETH to start the game. The throne amount then increases by 42.86% for the next King (e.g., 7.143 ETH).</p>
                                            </div>
                                            <div>
                                                <p><strong>Can the King dissolve the kingdom?</strong></p>
                                                <p>No, the current King cannot dissolve their own kingdom.</p>
                                            </div>
                                            <div>
                                                <p><strong>What happens to the throne amount when a new King takes over?</strong></p>
                                                <p>The previous King receives 100% of the throne amount, and the new throne amount is set to the challenger’s payment multiplied by 1.4286.</p>
                                            </div>
                                            <div>
                                                <p><strong>How are fees applied?</strong></p>
                                                <p>ETH withdrawals have a 12% owner fee, 5% jackpot fee, and 5% referral fee (if applicable). ANT and referral withdrawals have no fees.</p>
                                            </div>
                                            <div>
                                                <p><strong>What is the jackpot?</strong></p>
                                                <p>The jackpot accumulates from 5% of ETH withdrawals and 50% of dissolution payments. It’s awarded to the King after a 3-minute reign.</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            )}

                            {activeSection === "miniapps" && (
                                <div className="ant-container py-8 px-4 max-w-6xl mx-auto">
                                    <h2 className="text-3xl font-bold text-[var(--primary)] mb-6">Mini Games - Coming Soon</h2>
                                    <div className="ant-card p-6 rounded-lg bg-[var(--card-bg)] shadow">
                                        <h3 className="text-xl font-semibold mb-4">Exciting Mini Games</h3>
                                        <p>Stay tuned for upcoming Mini Games that will enhance your Ant Kingdom experience!</p>
                                        <ul className="list-disc pl-6 mt-4">
                                            <li>Ant Colony Simulator - Build and manage your own ant colony.</li>
                                            <li>Token Staking - Stake your ANT tokens for additional rewards.</li>
                                            <li>Battle Arena - Compete with other players for prizes.</li>
                                            <li>More to be announced...</li>
                                        </ul>
                                        <p className="mt-4">Check back soon for updates and new ways to engage with the kingdom!</p>
                                    </div>
                                </div>
                            )}

                            <ActionModal
                                isOpen={modalOpen}
                                onClose={() => setModalOpen(false)}
                                action={modalAction}
                                throneAmount={throneAmount}
                                isGameActive={isGameActive}
                                onProceed={() => {
                                    if (modalAction === "becomeKing") handleBecomeKing();
                                    else if (modalAction === "dissolveKingdom") handleDissolveKingdom();
                                }}
                                loading={loading}
                                isCurrentKing={isCurrentKing}
                                fees={fees}
                            />

                            <footer className="ant-container py-4 text-center border-t border-[var(--accent)]">
                                <p>Ant Kingdom © 2025 - Built for the Colony</p>
                            </footer>
                        </div>
                    </ErrorBoundary>
                );
            }

            try {
                console.log("Rendering app...");
                const rootElement = document.getElementById("root");
                const root = ReactDOM.createRoot(rootElement);
                root.render(<App />);
                console.log("App rendered successfully.");
            } catch (err) {
                console.error("Render failed:", err);
                document.getElementById("root").innerHTML = `
                    <div className="ant-container py-8 text-red-300 text-center">
                        <h1 className="text-3xl font-bold">Colony Error</h1>
                        <p>Failed to load: ${err.message || "Unknown error"}</p>
                        <ul className="list-disc pl-16 text-left max-w-md mx-auto">
                            <li>Refresh the page.</li>
                            <li>Disable ad blockers.</li>
                            <li>Check your connection.</li>
                            <li>Use Chrome or Firefox.</li>
                        </ul>
                    </div>
                `;
            }
        })();
    </script>
</body>
</html>
